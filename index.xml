<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>咸鱼白的窝</title>
    <link>https://blanca.world/</link>
    <description>Recent content on 咸鱼白的窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>咸鱼白</copyright>
    <lastBuildDate>Sun, 31 Jan 2021 13:47:29 +0800</lastBuildDate>
    
        <atom:link href="https://blanca.world/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>一个C&#43;&#43;协程库的实现与优化</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%8714-%E4%B8%80%E4%B8%AAc&#43;&#43;%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
        <pubDate>Sun, 31 Jan 2021 13:47:29 +0800</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%8714-%E4%B8%80%E4%B8%AAc&#43;&#43;%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%8714-%E4%B8%80%E4%B8%AAc&#43;&#43;%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/ -&lt;h2 id=&#34;预备知识&#34;&gt;预备知识&lt;/h2&gt;
&lt;p&gt;在阅读本文之前，你应当:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;理解&lt;code&gt;阻塞I/O与非阻塞I/O&lt;/code&gt;，&lt;code&gt;同步调用与异步调用&lt;/code&gt;的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熟悉&lt;code&gt;操作系统任务切换的过程（上下文的切换与保存）&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解&lt;code&gt;X86-64-ABI&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;了解&lt;code&gt;Linux下的I/O多路复用&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文所述的协程库源代码可以在我的&lt;a href=&#34;https://github.com/xclwt/Coroutine&#34;&gt;github仓库&lt;/a&gt;获得。&lt;/p&gt;
&lt;h2 id=&#34;协程是什么&#34;&gt;协程是什么&lt;/h2&gt;
&lt;p&gt;(∩_∩)这种概念我就不慢慢解释了（偷个懒），自己查。&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;h3 id=&#34;schedule&#34;&gt;Schedule&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Schedule::Schedule();

Schedule::Schedule(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; size);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一种方法会创建一个拥有1MB共享栈的schedule，该schedule创建的所有的共享栈协程都会共享这个1MB的运行栈。&lt;/p&gt;
&lt;p&gt;第二种方法会创建一个schedule，其拥有的共享栈大小由&lt;code&gt;stack_size&lt;/code&gt;参数决定。&lt;/p&gt;
&lt;p&gt;即使一个schedule管理的所有协程都具有独立运行栈，使用者也必须为schedule创建至少100字节的共享栈。在我的设计中，所有协程在运行到末尾时都会销毁自有的栈，所有独立运行栈协程都必须在最后将运行栈切换到共享栈上以销毁其自有的独立运行栈（具体分析请见&lt;code&gt;优化方案&lt;/code&gt;中&lt;code&gt;具有独立运行栈的协程&lt;/code&gt;部分）。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_create&#34;&gt;coroutine_create&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Schedule::coroutine_create(co_func func, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *args);

&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Schedule::coroutine_create(co_func func, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *args, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; stack_type, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; stack_size);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一个方法会创建一个共享运行栈协程，该方法等价于: &lt;code&gt;Schedule::coroutine_create(func, args, SAVED_STACK, 0);&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二个方法在 &lt;code&gt;stack_type&lt;/code&gt; 为&lt;code&gt;SAVED_STACK&lt;/code&gt;时会创建一个共享运行栈协程，&lt;code&gt;stack_size&lt;/code&gt;决定了用来保存运行栈内容的内存区域的初始大小，该内存区域大小会随着每次的协程挂起而动态调整，所以建议将&lt;code&gt;stack_size&lt;/code&gt;设为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二个方法在 &lt;code&gt;stack_type&lt;/code&gt; 为&lt;code&gt;INDEPENDENT_STACK&lt;/code&gt;时会创建一个独立运行栈协程，&lt;code&gt;stack_size&lt;/code&gt;决定了独立运行栈的大小。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_destroy&#34;&gt;coroutine_destroy&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; Schedule::coroutine_destroy(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; co_id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法会销毁由&lt;code&gt;co_id&lt;/code&gt;指定的协程。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_resume&#34;&gt;coroutine_resume&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; Schedule::coroutine_resume(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; co_id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法会将主协程切换到非主协程（由参数&lt;code&gt;co_id&lt;/code&gt;指定）。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_yield&#34;&gt;coroutine_yield&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; Schedule::coroutine_yield();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法会将正在运行的非主协程挂起并切换到主协程。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_status&#34;&gt;coroutine_status&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Schedule::coroutine_status(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; co_id);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法会返回一个协程（由参数&lt;code&gt;co_id&lt;/code&gt;指定）的状态，状态（在&lt;code&gt;coroutine.h&lt;/code&gt;中定义）可分为&lt;code&gt;COROUTINE_DEAD&lt;/code&gt;, &lt;code&gt;COROUTINE_READY&lt;/code&gt;, &lt;code&gt;COROUTINE_RUNNING&lt;/code&gt;, &lt;code&gt;COROUTINE_SUSPEND&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;coroutine_running&#34;&gt;coroutine_running&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; Schedule::coroutine_running() &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;const&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个方法会返回正在运行的协程的id。&lt;/p&gt;
&lt;h2 id=&#34;基本实现&#34;&gt;基本实现&lt;/h2&gt;
&lt;p&gt;基础的版本是去年读了&lt;a href=&#34;https://github.com/cloudwu&#34;&gt;云风前辈&lt;/a&gt;的&lt;a href=&#34;https://github.com/cloudwu/coroutine&#34;&gt;C coroutine&lt;/a&gt;源码后实现的&lt;a href=&#34;https://github.com/xclwt/Coroutine/tree/fb936e8fbadd4530fef32e64c3015642f8236b68&#34;&gt;C++ coroutine&lt;/a&gt;，这一版仅有共享运行栈协程。&lt;/p&gt;
&lt;p&gt;后续的各种改进与优化都是基于这一版本。&lt;/p&gt;
&lt;p&gt;该库主要由Schedule类和Coroutine类组成，创建schedule的程序被我们称为主协程，主协程未与任何一个Coroutine实例绑定，schedule创建的协程则称为非主协程，每一个非主协程都和一个Coroutine实例绑定。&lt;/p&gt;
&lt;p&gt;协程分为四种状态：&lt;code&gt;COROUTINE_DEAD&lt;/code&gt;, &lt;code&gt;COROUTINE_READY&lt;/code&gt;, &lt;code&gt;COROUTINE_RUNNING&lt;/code&gt;, &lt;code&gt;COROUTINE_SUSPEND&lt;/code&gt;，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xclwt-blog-image.oss-cn-hangzhou.aliyuncs.com/21-1-30/status.png&#34; alt=&#34;协程状态图&#34;&gt;&lt;/p&gt;
&lt;p&gt;schedule调用&lt;code&gt;coroutine_create&lt;/code&gt;方法创建一个非主协程，此时该协程处于&lt;code&gt;COROUTINE_READY&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;当主协程的schedule第一次调用&lt;code&gt;coroutine_resume&lt;/code&gt;方法切入一个处于&lt;code&gt;COROUTINE_READY&lt;/code&gt;状态的非主协程时，会将schedule拥有的共享栈设为非主协程的运行栈，将非主协程上下文中的&lt;code&gt;uc_link&lt;/code&gt;设置为主协程上下文（非主协程运行完会自动切换回主协程）并使用&lt;code&gt;makecontext&lt;/code&gt;函数为非主协程构建上下文，最终调用&lt;code&gt;swapcontext&lt;/code&gt;函数将上下文切至非主协程，该非主协程由此进入&lt;code&gt;COROUTINE_RUNNING&lt;/code&gt;状态，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;getcontext(&amp;amp;co-&amp;gt;ucontext);

co-&amp;gt;ucontext.uc_stack.ss_sp = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;stack;
co-&amp;gt;ucontext.uc_stack.ss_size = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;stack_size;

&lt;span style=&#34;color:#228b22&#34;&gt;/*ucontext will change to main after non-main co return*/&lt;/span&gt;
co-&amp;gt;ucontext.uc_link = &amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;main;
co-&amp;gt;status = COROUTINE_RUNNING;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;running_id = co_id;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; S_ptr = (uintptr_t) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;;
makecontext(&amp;amp;co-&amp;gt;ucontext, (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; (*)()) start_func, &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;, (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;uint32_t&lt;/span&gt;) S_ptr, (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;uint32_t&lt;/span&gt;) (S_ptr &amp;gt;&amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;32&lt;/span&gt;));

&lt;span style=&#34;color:#228b22&#34;&gt;/*main co to non-main co*/&lt;/span&gt;
swapcontext(&amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;main, &amp;amp;co-&amp;gt;ucontext);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当运行中的非主协程调用&lt;code&gt;coroutine_yield&lt;/code&gt;方法时，schedule会调用&lt;code&gt;save_stack&lt;/code&gt;函数将共享运行栈中的内容保存到当前运行的非主协程的保存栈中，调用&lt;code&gt;swapcontext&lt;/code&gt;函数将上下文切至主协程，非主协程变为&lt;code&gt;COROUTINE_SUSPEND&lt;/code&gt;状态，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; co_id = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;running_id;
Coroutine *co = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;co_list[co_id];
co-&amp;gt;status = COROUTINE_SUSPEND;

save_stack(co, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;stack + STACK_SIZE);

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;running_id = -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;/*non-main co to main co*/&lt;/span&gt;
swapcontext(&amp;amp;co-&amp;gt;ucontext, &amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;main);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当schedule调用&lt;code&gt;coroutine_resume&lt;/code&gt;函数切入一个处于&lt;code&gt;COROUTINE_SUSPEND&lt;/code&gt;的非主协程时，将非主协程保存栈中的内容恢复到schedule的共享运行栈中，调用&lt;code&gt;swapcontext&lt;/code&gt;函数将上下文切至非主协程，该非主协程由此变回&lt;code&gt;COROUTINE_RUNNING&lt;/code&gt;状态，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;memcpy(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;stack + STACK_SIZE - co-&amp;gt;size, co-&amp;gt;stack, co-&amp;gt;size);

co-&amp;gt;status = COROUTINE_RUNNING;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;running_id = co_id;

swapcontext(&amp;amp;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;main, &amp;amp;co-&amp;gt;ucontext);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;无论一个协程处于什么状态（除了&lt;code&gt;COROUTINE_RUNNING&lt;/code&gt;状态），只要对其调用&lt;code&gt;coroutine_destroy&lt;/code&gt;函数即可销毁该协程。&lt;/p&gt;
&lt;h2 id=&#34;优化方案&#34;&gt;优化方案&lt;/h2&gt;
&lt;h3 id=&#34;具有独立运行栈的协程&#34;&gt;具有独立运行栈的协程&lt;/h3&gt;
&lt;p&gt;为了区分共享运行栈协程和独立运行栈协程， 在Coroutine类中增加了&lt;code&gt;type&lt;/code&gt;成员， 构造Coroutine时会为&lt;code&gt;type == INDEPENDENT_STACK&lt;/code&gt;分配独立运行栈，在Schedule类中增加了成员函数&lt;code&gt;int coroutine_create(co_func func, void *args, int stack_type, int stack_size);&lt;/code&gt;,  &lt;code&gt;stack_type&lt;/code&gt;指定了协程类型， &lt;code&gt;stack_size&lt;/code&gt;指定了独立运行栈的大小（字节）。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;coroutine_resume&lt;/code&gt;函数中，对两种协程的处理做了判断区分，对于处于&lt;code&gt;COROUTINE_READY&lt;/code&gt;状态的独立运行栈协程，上下文的栈区将初始化为独立运行栈，对于处于&lt;code&gt;COROUTINE_SUSPEND&lt;/code&gt;状态的独立运行栈协程，取消了恢复栈区的操作，直接切换上下文即可。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;coroutine_yield&lt;/code&gt;函数中，对于独立运行栈协程，取消了保存栈区的操作，直接进行上下文切换。&lt;/p&gt;
&lt;p&gt;一点小插曲，在我初版的共享栈协程实现中，协程结束前会释放对应的Coroutine对象的内存（包括其保存栈），免去了库使用者手动释放已结束协程的麻烦，但增加了独立运行栈协程后，协程结束前释放对应的Coroutine对象的内存这一操作将引发对内存的越界访问（单线程运行时看似不会出错，但在多线程情况下存在隐患），我在撰写本文时意识到了这一bug，并采取了复制栈内容至共享栈，将rsp寄存器内容指向共享栈对应的新“栈顶”的解决方案，代码实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (co-&amp;gt;type == INDEPENDENT_STACK){
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;register&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; rsp &lt;span style=&#34;color:#008b45&#34;&gt;asm&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;rsp&amp;#34;&lt;/span&gt;);

	co-&amp;gt;size = co-&amp;gt;stack + co-&amp;gt;cap - (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)rsp;
	memcpy(S-&amp;gt;stack + S-&amp;gt;stack_size - co-&amp;gt;size, (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)rsp, co-&amp;gt;size);
	rsp = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt;)S-&amp;gt;stack + S-&amp;gt;stack_size - co-&amp;gt;size;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;基于这一实现，即使一个schedule管理的所有协程都具有独立运行栈，使用者也必须为schedule创建至少100字节的共享栈。&lt;/p&gt;
&lt;h3 id=&#34;上下文切换优化&#34;&gt;上下文切换优化&lt;/h3&gt;
&lt;p&gt;在初版实现中，上下文切换使用的是&lt;code&gt;ucontext.h&lt;/code&gt;中提供的&lt;code&gt;ucontext_t&lt;/code&gt;结构及相关库函数，然而该实现中涉及的FPU（浮点运算器），MXCSR（控制状态寄存器）在服务器端编程中极少用到，因此对这些寄存器的保存与恢复造成了不必要的性能消耗，这里参考了腾讯的libco的上下文切换并进行了精简（腾讯的libco涉及14个8字节数据的切换，其实我觉得根据那个实现完全可以精简成10个）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;.globl swap_ctx
.globl change_stack
.type  swap_ctx, @function

swap_ctx:
    leaq (%rsp),%rax
    movq %rax, 64(%rdi)

    movq %rbx, 56(%rdi)
    
    movq 0(%rax), %rax
    movq %rax, 48(%rdi)
    
    movq %rdi, 40(%rdi)
    movq %rbp, 32(%rdi)
    movq %r12, 24(%rdi)
    movq %r13, 16(%rdi)
    movq %r14, 8(%rdi)
    movq %r15, (%rdi)
    xorq %rax, %rax
    
    movq 32(%rsi), %rbp
    movq 64(%rsi), %rsp
    movq (%rsi), %r15
    movq 8(%rsi), %r14
    movq 16(%rsi), %r13
    movq 24(%rsi), %r12
    movq 40(%rsi), %rdi
    movq 56(%rsi), %rbx
    
    leaq 8(%rsp), %rsp
    pushq 48(%rsi)
    
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存以及恢复了参数寄存器rdi（这个寄存器对应&lt;code&gt;start_func&lt;/code&gt;的参数&lt;code&gt;S&lt;/code&gt;，其实只需要保证第一次切入时能从上下文中取出来而已，保存操作纯粹是强迫症对称罢了），返回地址（每次切换上下文时保证能回到之前调用切换函数的地方继续运行），7个callee-saved寄存器：rbx，rsp，rbp，r12，r13，r14，r15。&lt;/p&gt;
&lt;p&gt;用来取代的&lt;code&gt;ucontext_t&lt;/code&gt;的&lt;code&gt;coctx&lt;/code&gt;定义在&lt;code&gt;coctx.h&lt;/code&gt;中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;coctx&lt;/span&gt;{
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *regs[&lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;coctx&lt;/span&gt; *uc_link;
    stack_t uc_stack;
}coctx;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;stack_t&lt;/code&gt;类型（见 &lt;code&gt;bits/types/stack_t.h&lt;/code&gt;）的&lt;code&gt;uc_stack&lt;/code&gt;和&lt;code&gt;ucontext_t&lt;/code&gt;中的作用一样，用于初始化上下文时确定栈空间，&lt;code&gt;regs[9]&lt;/code&gt;中即是上面提到的返回地址与8个寄存器。&lt;code&gt;uc_link&lt;/code&gt;用来指定当前协程运行结束后的上下文，在本库中，所有非主协程上下文中的&lt;code&gt;uc_link&lt;/code&gt;都指向了主协程的上下文。&lt;/p&gt;
&lt;p&gt;值得一提的是，腾讯的libco并没有提供类似uc_link的实现，libco似乎默认所有的协程函数都是处于永不终止的循环中，并且简单粗暴的把所有协程的返回地址都指向了协程函数的入口。。直觉告诉我在这种实现下，如果库使用者的协程会运行到结尾，极有可能引发错误，但因为libco缺少详细文档，加上我并没有完全细究其代码，所以对这种情况我也无法断言必然出错，也许有什么容错机制吧。&lt;/p&gt;
&lt;p&gt;因为对&lt;code&gt;uc_link&lt;/code&gt;的需求，所以我去看了一下glibc中&lt;code&gt;makecontext&lt;/code&gt;函数的&lt;a href=&#34;https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/makecontext.c.html#11sp&#34;&gt;源码&lt;/a&gt;，结合上面的&lt;code&gt;coctx&lt;/code&gt;结构体，实现了&lt;code&gt;make_ctx&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;make_ctx&lt;/span&gt;(coctx *ctx, co_start func, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *s){
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;auto&lt;/span&gt; *sp = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; *)((uintptr_t)ctx-&amp;gt;uc_stack.ss_sp + ctx-&amp;gt;uc_stack.ss_size);

    &lt;span style=&#34;color:#228b22&#34;&gt;/* 16 Bytes room reserved for uc_link and start_ctx addr*/&lt;/span&gt;
    sp -= &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;

    &lt;span style=&#34;color:#228b22&#34;&gt;/* Align stack, 8 Bytes room reserved for swap_ctx ret addr */&lt;/span&gt;
    sp = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;long&lt;/span&gt; *)(((uintptr_t)sp &amp;amp; -&lt;span style=&#34;color:#b452cd&#34;&gt;16L&lt;/span&gt;) - &lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;);

    ctx-&amp;gt;regs[RSP] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)sp;
    ctx-&amp;gt;regs[RBX] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)&amp;amp;sp[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
    ctx-&amp;gt;regs[RDI] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)s;
    ctx-&amp;gt;regs[RET] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; *)func;

    sp[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;] = (uintptr_t)start_ctx;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ctx-&amp;gt;uc_link)
        sp[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;] = (uintptr_t)ctx-&amp;gt;uc_link;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
        sp[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;] = (uintptr_t)func;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除去一些对基本上下文的初始化，&lt;code&gt;make_ctx&lt;/code&gt;确保在栈底预留了16字节给&lt;code&gt;uc_link&lt;/code&gt;与&lt;code&gt;start_ctx&lt;/code&gt;函数地址，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;high memory
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;uc_link		&amp;lt;--stack base
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;start_ctx
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;start_func	&amp;lt;--rsp
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;...
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;low memory
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;make_ctx&lt;/code&gt;将&lt;code&gt;rsp&lt;/code&gt;指向&lt;code&gt;start_ctx&lt;/code&gt;上面一个栈帧，在第一次调用&lt;code&gt;swap_ctx&lt;/code&gt;进入协程时，会在&lt;code&gt;rsp&lt;/code&gt;指向的栈帧中存入协程入口&lt;code&gt;start_func&lt;/code&gt;地址，然后&lt;code&gt;ret&lt;/code&gt;以进入协程，此时&lt;code&gt;rsp&lt;/code&gt;重新指向&lt;code&gt;start_ctx&lt;/code&gt;，栈由此向下扩展，当协程运行结束，&lt;code&gt;rsp&lt;/code&gt;指回&lt;code&gt;start_ctx&lt;/code&gt;，协程退出时&lt;code&gt;ret&lt;/code&gt;直接进入&lt;code&gt;start_ctx&lt;/code&gt;，其实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;.globl start_ctx
.globl __set_ctx
.type  start_ctx, @function
start_ctx:
    movq (%rsp), %rdi

    call __set_ctx

__set_ctx:
    movq 32(%rdi), %rbp
    movq 64(%rdi), %rsp
    movq (%rdi), %r15
    movq 8(%rdi), %r14
    movq 16(%rdi), %r13
    movq 24(%rdi), %r12
    movq 40(%rdi), %rdi
    movq 56(%rdi), %rbx

    leaq 8(%rsp), %rsp
    pushq 48(%rdi)
    
    ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将&lt;code&gt;uc_link&lt;/code&gt;取出至&lt;code&gt;rdi&lt;/code&gt;寄存器，然后调用&lt;code&gt;__set_ctx&lt;/code&gt;函数将上下文切换回主协程。&lt;/p&gt;
&lt;p&gt;在实现&lt;code&gt;uc_link&lt;/code&gt;的过程中，我没有将&lt;code&gt;rsp&lt;/code&gt;寄存器设置到位，导致&lt;code&gt;set_start&lt;/code&gt;的地址被&lt;code&gt;start_func&lt;/code&gt;的地址覆盖了，debug时整出了&lt;code&gt;uc_link&lt;/code&gt;的另一种用法，即在协程中直接获取&lt;code&gt;uc_link&lt;/code&gt;的值并将其作为参数在协程结束前调用&lt;code&gt;__set_ctx&lt;/code&gt;从而完成跳转，两种实现性能基本无区别，默认使用第二种实现，如果想使用第一种实现，可以 &lt;code&gt;#define USE_UC_LINK&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;协程库默认使用coctx这一实现，如果想要使用ucontext_t的实现，可以&lt;code&gt;#define USE_SYS_UCONTEXT&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;性能比较&#34;&gt;性能比较&lt;/h3&gt;
&lt;p&gt;100,000,000次协程切换总时长：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;USE_SYS_UCONTEXT&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;USE_UC_LINK&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;时间（s）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;共享运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.125&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;共享运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7.230&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;共享运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无作用&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;91.81&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;独立运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.749&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;独立运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;否&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5.697&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;独立运行栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;是&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无作用&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;89.52&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通过对比我们可以看出使用没有FPU信息和MXCSR信息的&lt;code&gt;coctx&lt;/code&gt;代替glibc提供的&lt;code&gt;ucontext_t&lt;/code&gt;进行上下文切换后，整体速度提升超过了10倍。且独立运行栈的上下文切换速度也明显优于共享运行栈的上下文切换速度（在实际应用中，共享运行栈中含有大量数据时，这种切换速度的差距会更明显）。&lt;/p&gt;
&lt;h2 id=&#34;简略谈谈libco&#34;&gt;简略谈谈libco&lt;/h2&gt;
&lt;p&gt;本来很想尝试像&lt;a href=&#34;https://github.com/Tencent/libco&#34;&gt;libco&lt;/a&gt;那样hook几个阻塞IO调用，但最近事情太多，暂时没那个精力去实现，这里简略地聊聊libco hook的大致思路吧。&lt;/p&gt;
&lt;p&gt;libco通过&lt;code&gt;LD_PRELOAD&lt;/code&gt;（详见&lt;a href=&#34;https://man7.org/linux/man-pages/man8/ld-linux.so.8.html&#34;&gt;ld.so(8)&lt;/a&gt;）优先于系统的库函数加载进内存，运行时调用的将是libco hook后的IO调用，而真实的系统IO调用的函数指针则通过&lt;a href=&#34;https://man7.org/linux/man-pages/man3/dlsym.3.html&#34;&gt;dlsym(3)&lt;/a&gt;取得，比如真实的read调用的函数指针通过&lt;code&gt;static read_pfn_t g_sys_read_func = (read_pfn_t)dlsym(RTLD_NEXT,&amp;quot;read&amp;quot;);&lt;/code&gt;获得，现在&lt;code&gt;g_sys_read_func&lt;/code&gt;指向真正的&lt;code&gt;read&lt;/code&gt;调用。&lt;/p&gt;
&lt;p&gt;我们来看看hook后的&lt;code&gt;read&lt;/code&gt;的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;ssize_t &lt;span style=&#34;color:#008b45&#34;&gt;read&lt;/span&gt;( &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; fd, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; *buf, size_t nbyte )
{
	HOOK_SYS_FUNC( read );
	

	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;( !co_is_enable_sys_hook() )
	{
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; g_sys_read_func( fd,buf,nbyte );
	}
	rpchook_t *lp = get_by_fd( fd );
	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;( !lp || ( O_NONBLOCK &amp;amp; lp-&amp;gt;user_flag ) ) 
	{
		ssize_t ret = g_sys_read_func( fd,buf,nbyte );
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ret;
	}
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; timeout = ( lp-&amp;gt;read_timeout.tv_sec * &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt; ) 
				+ ( lp-&amp;gt;read_timeout.tv_usec / &lt;span style=&#34;color:#b452cd&#34;&gt;1000&lt;/span&gt; );
	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;pollfd&lt;/span&gt; pf = { &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; };
	pf.fd = fd;
	pf.events = ( POLLIN | POLLERR | POLLHUP );
	
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; pollret = poll( &amp;amp;pf,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;,timeout );
	
	ssize_t readret = g_sys_read_func( fd,(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;*)buf ,nbyte );
	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;( readret &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; )
	{
		co_log_err(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;CO_ERR: read fd %d ret %ld errno %d poll ret %d timeout %d&amp;#34;&lt;/span&gt;,
					fd,readret,errno,pollret,timeout);
	}
	
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; readret;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于设置了&lt;code&gt;O_NONBLOCK&lt;/code&gt;标志位的文件描述符，将直接通过&lt;code&gt;g_sys_read_func&lt;/code&gt;调用真实的&lt;code&gt;read&lt;/code&gt;，而对于阻塞的文件描述符，会加入poll轮询列表，等到poll返回后才通过&lt;code&gt;g_sys_read_func&lt;/code&gt;调用真实的&lt;code&gt;read&lt;/code&gt;，这里的&lt;code&gt;poll&lt;/code&gt;也是经过了hook改造的，所有的hook后的函数的核心都在于这个&lt;code&gt;poll&lt;/code&gt;，hook后的&lt;code&gt;poll&lt;/code&gt;内部实现是&lt;code&gt;co_poll_inner&lt;/code&gt;，&lt;code&gt;co_poll_inne&lt;/code&gt;会为文件描述符注册epoll事件，且如果设定了&lt;code&gt;timeout&lt;/code&gt;参数，&lt;code&gt;co_poll_inne&lt;/code&gt;还会将文件描述符相关的结构加入定时器队列，随后让出当前协程。当主协程中的&lt;code&gt;co_eventloop&lt;/code&gt;触发监听事件时抑或是定时器队列触发超时，都会将对应协程切回来，此时会发起第二次&lt;code&gt;poll&lt;/code&gt;，如果判断出是IO事件唤醒了协程，则会通过&lt;code&gt;g_sys_read_func&lt;/code&gt;调用真实的&lt;code&gt;read&lt;/code&gt;，如果判断出超时，则会重复之前的流程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;背后的具体实现比较复杂，我也只理清了个大概，若是展开细讲，大概又是好几万字，只能像这样粗略地描述一下以作记录了。&lt;/p&gt;
&lt;h2 id=&#34;tips&#34;&gt;Tips&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注意共享栈协程和独立栈协程的选择，共享栈协程因为栈数据的保存与恢复操作，会使得性能下降，独立栈协程则更容易产生栈溢出的风险以及大量内存的占用。&lt;/li&gt;
&lt;li&gt;在共享栈协程中使用异步IO调用时，必须使用堆中分配的内存作为缓冲区，不可以将栈上的空间作为缓冲区，因为一旦协程挂起，运行栈就不再归属于该协程。在独立栈协程中则无此限制。&lt;/li&gt;
&lt;li&gt;在本库提供的协程中最好使用非阻塞调用而非阻塞调用，阻塞调用会使协程失去存在的必要性。（因为没有像libco一样实现对常用网络编程函数的hook，所以程序使用的第三方库中如果使用了阻塞调用，同样会使协程失去存在必要性）。&lt;/li&gt;
&lt;/ul&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%8714-%E4%B8%80%E4%B8%AAc&#43;&#43;%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%98%E5%8C%96/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>迟到的2020年终总结</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%8713-2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
        <pubDate>Sat, 23 Jan 2021 19:11:11 +0800</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%8713-2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%8713-2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ -&lt;p&gt;这里是咸鱼白没人看的博客，能看到这篇迟到的2020年终总结的大抵都是那几个在深夜倾听过我诉说的朋友，如果看到这里的你恰巧是个陌生人还愿意看完我的胡言乱语，那么，提前祝你晚安。&lt;/p&gt;
&lt;p&gt;2020年于我而言算是人生的转折点，距离上一个人生转折点刚好十年，整整十年，还真是够巧的。&lt;/p&gt;
&lt;p&gt;上半年，我一直在努力完成2019年年终总结中定下的目标，即Blanca-OS的实现，在六月的时候基本只剩内存管理模块遗留的bug以及文件系统没完成了，暑假暂时放了放这一项目，去研究了一下Linux系统编程以及协程相关的内容，原计划九月开学继续写完Blanca-OS，可惜终究因为下半年的变故搁置了，不过虽然我至今仍未完成Blanca-OS，但我个人感觉自己的综合能力（对程序背后运行过程的理解，对有效信息的检索，对调试工具的运用等等）已经在上半年的磨砺中产生了飞跃并在近阶段的编程实践中得到了很好的体现。&lt;/p&gt;
&lt;p&gt;下半年，父亲查出肝癌晚期，然后过世，说实话，对我打击很大。下半年有那么一段时间内我无法进入以往的状态，常常躺在床上审视过去十年的人生。&lt;/p&gt;
&lt;p&gt;我以前经常看不懂自己到底是个什么样的人，我一直活得很奇怪，现在我想给以前的自己下个定义：一个本质极度感性却又崇尚绝对理性却又无法做到的理想主义者。&lt;/p&gt;
&lt;p&gt;童年的一些经历让我变得早熟且善于察觉别人的情绪变化，然而很多人都觉得我不会照顾别人的感受，实际上，我知道他们的感受，但我若是觉得自己的行为从逻辑上不构成错误，我会强行忽视观察到的情绪因素，我行我素。长久以来，我觉得我给自己装了一把锁，把自己的感性锁了起来，绝大多数负面的影响作用于我时，我也都会把它们锁起来，强行回避掉，只有在我身体不适时，这把锁才可能会松开一些，露出我更为感性且真实的一面。我可活得真拧巴。这两年，这把锁愈发像是坏了，兴许是锁住的太多，终于慢慢地挤坏了那把锁，我也开始越来越多地流露出感性的一面，愈发容易对他人倾诉心中苦郁，虽然有悖于我长期所持的理性至上的理念，但其实也挺不错，起码我感觉自己活得更像一个正常的“人”了。&lt;/p&gt;
&lt;p&gt;我一直以来其实都是个很不负责任的人，十年前的经历让我变得惧怕责任且善于逃避责任，然而迟早有一天现实会教我做人，让我后悔，我希望2020年是我最后一次为自己的逃避而后悔。父亲走前并没有留下什么遗言，只是走前一晚让我打开他的邮箱，我当时答应他“好的，你要相信你儿子，有什么事情我都会处理好的”。最终我在他邮箱里找到三封给我的邮件，一封是他为防自己发生意外早已写好的遗书，交代的事情暂且不表。还有两封是早就写好的给我的信，但却一直没有发出，一封讲述了一个“朋友”的故事，关于这个“朋友”从小到大干过的很多蠢事，写给我以作前车之鉴，另一封是关于责任的信，他试图以切身体会教导我做为父亲该承担对儿子的责任，作为丈夫该承担对妻子的责任，作为儿子对父母的责任，知子莫若父，原来他也觉得他的儿子很不负责任吗？他去世后我时常翻看他写给我的邮件，时常反思自己过去的所作所为，我觉得我能完成那晚对他的承诺。&lt;/p&gt;
&lt;p&gt;曾经不愿意和父母谈心，没想到和母亲能够交心谈话是在父亲走后，父亲在世的时候的各种说教我从来不愿意认真去听，临到他走了，我反而开始郑重其事地要信守承诺了，要开始接受他的教导了，呵，我这种人，多可笑！我以前总喜欢理想化一切，总认为事情会怎么这么地按照自己的规划发展，我常常对十年后，二十年后，三十年的我的生活会是怎样充满了期待，然鹅现实冷酷无情地把我扇醒，指不定这篇博文还没写完我就暴毙当场了呢？前一阵子看了一部很长很平淡的电影《少年时代》，深有感触，过去和未来，都不属于我，真正属于我的，只有现在这一瞬罢了，我能做的唯有珍惜当下拥有的一切，尽力做好现在的自己，这才是我的生活。&lt;/p&gt;
&lt;p&gt;2020年末，向一个很久没见的朋友为曾经的不愉快道了歉，虽然这份歉意迟到了，但我仍然为自己能够勇敢地道歉感到开心，祝ta一切顺利，有缘再见。&lt;/p&gt;
&lt;p&gt;现在，站在2021年年初，站在下一个十年开始的地方，我终于看懂了过去十年的我到底是个什么样的人，而现在的我，又到底是什么样的人？有了什么改变？又有什么没变？我今天总结出的到底有多少是我真正参悟透了的？我不知道，兴许要等到十年后回顾时才能得到答案。但这并不重要，起码我知道现在我应该做一个什么样的人，然后在每一个现在努力做好自己，这就够了。&lt;/p&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%8713-2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>关于splice调用中易出现的一个bug的记录</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%8712-%E5%85%B3%E4%BA%8Esplice%E8%B0%83%E7%94%A8%E4%B8%AD%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Sun, 17 Jan 2021 23:40:11 +0800</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%8712-%E5%85%B3%E4%BA%8Esplice%E8%B0%83%E7%94%A8%E4%B8%AD%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E8%AE%B0%E5%BD%95/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%8712-%E5%85%B3%E4%BA%8Esplice%E8%B0%83%E7%94%A8%E4%B8%AD%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E8%AE%B0%E5%BD%95/ -&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;p&gt;这两天打算过一遍《Linux高性能服务器编程》，虽然都是些熟悉的知识，但我还是把该书的源码一个个运行了试了试。然后发现了&lt;a href=&#34;https://github.com/raichen/LinuxServerCodes/blob/master/6/6-5testtee.cpp&#34;&gt;6-5testtee.cpp&lt;/a&gt;存在bug。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;( &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;* argv[] )
{
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; ( argc != &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; )
	{
		printf( &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;usage: %s &amp;lt;file&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;, argv[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;] );
		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; filefd = open( argv[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;], O_CREAT | O_WRONLY | O_TRUNC, &lt;span style=&#34;color:#b452cd&#34;&gt;0666&lt;/span&gt; );
	assert( filefd &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; );

	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = pipe( pipefd_stdout );
	assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );

	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; pipefd_file[&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;];
        ret = pipe( pipefd_file );
	assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );

	ret = splice( STDIN_FILENO, &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;32768&lt;/span&gt;, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );

	ret = tee( pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;], pipefd_file[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#b452cd&#34;&gt;32768&lt;/span&gt;, SPLICE_F_NONBLOCK ); 
	assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );
	ret = splice( pipefd_file[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, filefd, &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;32768&lt;/span&gt;, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );
    
    ret = splice( pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, STDOUT_FILENO, &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;32768&lt;/span&gt;, SPLICE_F_GIFT );
    printf(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;errno:%d&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&lt;/span&gt;,errno);

    assert( ret != -&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; );


	close( filefd );
        close( pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;] );
        close( pipefd_stdout[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;] );
        close( pipefd_file[&lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;] );
        close( pipefd_file[&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;] );
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该代码的第三次splice系统调用本应该将stdin的内容输出到stdout，但在我的terminal中运行时该系统调用失败了，错误码22。&lt;/p&gt;
&lt;p&gt;起初我尝试用gdb调试，结果系统调用在gdb中成功了。。。很离谱。查了一圈，上&lt;a href=&#34;https://stackoverflow.com/questions/65749455/why-splice-syscall-fails-when-my-program-runs-on-linux-but-succeeds-when-it-runs/65751382#65751382&#34;&gt;stackoverflow&lt;/a&gt;开了个问题，结果那上面的老哥说复现不了。&lt;/p&gt;
&lt;p&gt;又回头找朋友复现、讨论，在此过程中又发现：在我的manjaro下，clion的run console，dolphin的Terminal，gdb调试窗口都能正确运行该代码，clion的Terminal以及各种其他的自行启动的Terminal都无法正确运行该代码。排查半天得到结论的时候恨不得扇自己一巴掌。&lt;/p&gt;
&lt;h3 id=&#34;解决办法&#34;&gt;解决办法&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;man 2 splice&lt;/code&gt;查看splice的文档时，关于其Errors的描述有这么一条：&lt;code&gt;EINVAL The target file is opened in append mode.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我的manjaro上所有无法正确运行该代码的Terminal的标准输出都处于Append模式下，因而导致了splice系统调用失败。&lt;/p&gt;
&lt;p&gt;只需要在调用之前添加&lt;code&gt;fcntl(STDOUT_FILENO, F_SETFL, fcntl(STDOUT_FILENO, F_GETFL) &amp;amp; ~O_APPEND);&lt;/code&gt;取消stdout的Append模式就能解决该bug。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;其实发现bug后我第一时间就查阅了Linux Manual，然而却没有考虑到进程中所有文件描述符的状态，下意识忽略了STDOUT_FILENO这一特殊的并非手动打开的文件描述符，想当然地认为是系统调用本身的问题，白白浪费了大半天时间，需要吸取教训。&lt;/p&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%8712-%E5%85%B3%E4%BA%8Esplice%E8%B0%83%E7%94%A8%E4%B8%AD%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAbug%E7%9A%84%E8%AE%B0%E5%BD%95/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>干掉wine-qqmusic的黑框</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%8711-%E5%B9%B2%E6%8E%89wine-qqmusic%E7%9A%84%E9%BB%91%E6%A1%86/</link>
        <pubDate>Mon, 08 Jun 2020 20:25:11 +0800</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%8711-%E5%B9%B2%E6%8E%89wine-qqmusic%E7%9A%84%E9%BB%91%E6%A1%86/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%8711-%E5%B9%B2%E6%8E%89wine-qqmusic%E7%9A%84%E9%BB%91%E6%A1%86/ -&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;p&gt;manjaro最新的版本更新之后，界面更美观了，然鹅使用wine安装的QQ音乐四周出现了大面积黑框，强迫症感觉有被冒犯到。&lt;/p&gt;
&lt;h3 id=&#34;解决办法&#34;&gt;解决办法&lt;/h3&gt;
&lt;p&gt;安装wmctrl：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo pacman -S wmctrl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装xdotool：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo pacman -S xdotool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看当前窗口：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wmctrl -l -G -p -x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x02600013 -1 2898   0    0    1920 1080 plasmashell.plasmashell  xclwt-pc 桌面 — Plasma
0x03c00006  0 3096   130  157  1187 754  dolphin.dolphin       xclwt-pc 下载 — Dolphin
0x0260003a -1 2898   0    1035 1920 45   plasmashell.plasmashell  xclwt-pc Plasma
0x05a00007  0 3370184 0    29   960  488  konsole.konsole       xclwt-pc commands : zsh — Konsole
0x05000077  0 2082025 535  215  850  605  wechat.exe.wechat.exe  xclwt-pc 微信
0x06800006  0 4024859 379  101  1200 800  qqmusic.exe.qqmusic.exe  xclwt-pc QQ音乐
0x06800014  0 4024859 319  51   1320 920  qqmusic.exe.qqmusic.exe  xclwt-pc 
0x01c00007  0 2923   0    0    1920 1035 yakuake.yakuake       xclwt-pc ~ : sh — Yakuake
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出现了两个qqmusic.exe,其中一个就是出现错误的黑框，使用xdotool将该窗口关闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;xdotool windowclose 0x06800014&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此，问题暂时解决，但下次重新启动QQ音乐时仍需按同样步骤处理掉黑框。&lt;/p&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%8711-%E5%B9%B2%E6%8E%89wine-qqmusic%E7%9A%84%E9%BB%91%E6%A1%86/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>Blanca-OS设计之中断（待更新）</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%8710-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E6%96%AD/</link>
        <pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%8710-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E6%96%AD/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%8710-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E6%96%AD/ -&lt;h2 id=&#34;中断&#34;&gt;中断&lt;/h2&gt;
&lt;p&gt;中断，即CPU接收到一定的信号，打断了当前的程序控制流以处理其他事务的机制。
中断主要可分为两类：同步中断与异步中断。
其中，同步中断又称异常，可分为故障（fault），陷阱（trap），终止（abort）三类。异步中断则简称为中断。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;中断&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;故障&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;陷阱&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;终止&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;中断例程&#34;&gt;中断例程&lt;/h2&gt;
&lt;p&gt;Blanca-OS中的所有中断处理程序都要经过一段汇编实现的例程asm_isr_stub（见&lt;code&gt;kernel/idt_asm.asm&lt;/code&gt;），该例程将中断将中断发生时的程序信息（主要是寄存器）快照压栈并调用中断号对应的中断处理程序，该快照在C语言中以如下结构体表示（见inc/idt.h）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
	&lt;span style=&#34;color:#228b22&#34;&gt;/*段寄存器,16bit*/&lt;/span&gt;
	uint32_t fs;
	uint32_t gs;
	uint32_t es;
	uint32_t ds;
	
	&lt;span style=&#34;color:#228b22&#34;&gt;/*pusha保存的寄存器*/&lt;/span&gt;
	uint32_t edi;
	uint32_t esi;
	uint32_t ebp;
	uint32_t esp;
	uint32_t ebx;
	uint32_t edx;
	uint32_t ecx;
	uint32_t eax;

	&lt;span style=&#34;color:#228b22&#34;&gt;/*中断号*/&lt;/span&gt;
	uint32_t intr_num;

	&lt;span style=&#34;color:#228b22&#34;&gt;/*错误代码*/&lt;/span&gt;
	uint32_t err_code;

	uint32_t eip;
	uint32_t cs; &lt;span style=&#34;color:#228b22&#34;&gt;//16bit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	uint32_t eflags;

	&lt;span style=&#34;color:#228b22&#34;&gt;/*特权级切换时才会压入ss及esp*/&lt;/span&gt;
	uint32_t u_esp;
	uint32_t ss; &lt;span style=&#34;color:#228b22&#34;&gt;//16bit
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}regs_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;需要注意的是，并非所有的中断都会压入error code（错误代码），故中断发生时的程序快照结构体本应有两种，但此处为了方便后续程序的编写进行了统一，即在汇编macro生成的不压入错误代码的相关中断的处理程序中(见&lt;code&gt;kernel/idt_s.asm&lt;/code&gt;)自动在相应位置压入32字节数据，该数据值统一为0。&lt;/p&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%8710-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E4%B8%AD%E6%96%AD/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>Blanca-OS设计之线程，进程与锁（待更新）</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%879-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E9%94%81/</link>
        <pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%879-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E9%94%81/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%879-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E9%94%81/ -&lt;h2 id=&#34;线程与进程&#34;&gt;线程与进程&lt;/h2&gt;
&lt;p&gt;线程与进程都是程序执行流，其区别在于进程拥有独立的地址空间与一些资源，而线程则需与其所属进程中的其他的线程共享地址空间与一些资源。Blanca-OS中参考了linux中的实现，采用了”伪“线程的概念，将所有程序执行流（每一个线程/进程都分配一个PCB）统一归为任务（Task）进行调度。&lt;/p&gt;
&lt;h2 id=&#34;程序控制块pcb&#34;&gt;程序控制块（PCB）&lt;/h2&gt;
&lt;p&gt;Blanca-OS管理线程与线程时统一使用了程序控制块（PCB），程序控制块结构体task_struct设计如下（见&lt;code&gt;inc/thread.h&lt;/code&gt;）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
	uint8_t* kstack;
	uint8_t status;
	uint8_t priority;
	uint32_t run_time;
	list_node ready_list_node;
	list_node all_list_node;
	&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; name[&lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt;];
	uint32_t* pgdir;
	uint32_t stack_boundary;
}task_struct;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（待完善）&lt;/p&gt;
&lt;p&gt;严格来说，PCB并不仅限于这个结构体，还包含了kstack所指向的内核线程栈，整个PCB的内存结构如下图：&lt;/p&gt;
&lt;p&gt;（待添加）&lt;/p&gt;
&lt;h2 id=&#34;程序调度&#34;&gt;程序调度&lt;/h2&gt;
&lt;h4 id=&#34;程序切换&#34;&gt;程序切换&lt;/h4&gt;
&lt;p&gt;程序切换的操作由汇编实现（见thread/switch.asm），该操作保存了当前程序的上下文并切换到下一个程序去。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;switch_to:
	&lt;span style=&#34;color:#008b45&#34;&gt;mov&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;eax&lt;/span&gt;,[&lt;span style=&#34;color:#00688b&#34;&gt;esp&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;]
	&lt;span style=&#34;color:#008b45&#34;&gt;mov&lt;/span&gt; [&lt;span style=&#34;color:#00688b&#34;&gt;eax&lt;/span&gt;],&lt;span style=&#34;color:#00688b&#34;&gt;esp&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;mov&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;eax&lt;/span&gt;,[&lt;span style=&#34;color:#00688b&#34;&gt;esp&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;]

	&lt;span style=&#34;color:#008b45&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;esi&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;edi&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;ebx&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;push&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;ebp&lt;/span&gt;

	&lt;span style=&#34;color:#008b45&#34;&gt;mov&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;esp&lt;/span&gt;,[&lt;span style=&#34;color:#00688b&#34;&gt;eax&lt;/span&gt;]

	&lt;span style=&#34;color:#008b45&#34;&gt;pop&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;ebp&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;pop&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;ebx&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;pop&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;edi&lt;/span&gt;
	&lt;span style=&#34;color:#008b45&#34;&gt;pop&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;esi&lt;/span&gt;

	&lt;span style=&#34;color:#008b45&#34;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;switch_to函数按照ABI将上下文（esi，edi，ebx，ebp寄存器的内容，esp寄存器值由调用约定保存）保存在当前程序的内核栈中，并切换出下一个程序的上下文，最后通过ret切换到下一个程序。&lt;/p&gt;
&lt;h4 id=&#34;调度算法&#34;&gt;调度算法&lt;/h4&gt;
&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;
&lt;p&gt;现阶段，Blanca-OS仅支持单处理器，故目前对于共享资源只提供了互斥锁（mutex）这一种机制以避免竞争。互斥锁的原理即将抢锁失败的任务阻塞并等待锁的释放。其实现主要采用了&lt;code&gt;semaphore&lt;/code&gt;与&lt;code&gt;mutex_lock&lt;/code&gt;两种数据结构（见&lt;code&gt;inc/sync.h&lt;/code&gt;），锁的获取与释放代码如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;acquire_mutex&lt;/span&gt;(mutex_lock* mutex){
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(mutex-&amp;gt;holder != cur_thread()){
		sema_busy(&amp;amp;(mutex-&amp;gt;sig));		&lt;span style=&#34;color:#228b22&#34;&gt;//信号量设为忙碌
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		mutex-&amp;gt;holder = cur_thread();	&lt;span style=&#34;color:#228b22&#34;&gt;//将互斥锁持有者设为当前任务
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		mutex-&amp;gt;request_num = &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;			&lt;span style=&#34;color:#228b22&#34;&gt;//初始化互斥锁申请次数为1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
		++mutex-&amp;gt;request_num;			&lt;span style=&#34;color:#228b22&#34;&gt;//互斥锁申请次数加1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
}

&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;release_mutex&lt;/span&gt;(mutex_lock* mutex){
	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;(mutex-&amp;gt;request_num &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;){
		--mutex-&amp;gt;request_num;			&lt;span style=&#34;color:#228b22&#34;&gt;//互斥锁申请次数减1
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt;;
	}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;{
		--mutex-&amp;gt;reqauest_num;			
		mutex-&amp;gt;holder = &lt;span style=&#34;color:#658b00&#34;&gt;NULL&lt;/span&gt;;			&lt;span style=&#34;color:#228b22&#34;&gt;//清空持有者
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;		sema_free(&amp;amp;(mutex-&amp;gt;sig));		&lt;span style=&#34;color:#228b22&#34;&gt;//信号量设为空闲
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://blanca.world/archives/%E5%8D%9A%E6%96%879-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E9%94%81/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>Blanca-OS设计之内存管理（待更新）</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%878-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%878-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%878-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ -&lt;h3 id=&#34;内存分布&#34;&gt;内存分布&lt;/h3&gt;
&lt;p&gt;Blanca-OS假定使用者的内存大于1G，并将1G的内核空间永远映射于地址的3/4高位之上（3GB-4GB），而超出1G内存的部分则被分配为用户空间并映射于地址的低位（0-3GB）。内核空间参考linux的设计分为了3个zone：DMA ZONE（0-1MB），NORMAL ZONE（1-896MB），HIGHMEM ZONE（896MB+）。Blanca-OS目前的内存管理模块主要聚焦于对NORMAL ZONE的管理，其他zone的管理与使用需等待后期的开发。&lt;/p&gt;
&lt;h3 id=&#34;页管理结构&#34;&gt;页管理结构&lt;/h3&gt;
&lt;p&gt;Blanca-OS对页的管理主要使用了以下的结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;struct&lt;/span&gt;{
	list_node list;
	atomic_t count;
	uint32_t order;
	uint32_t flag;
}page_t;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;页管理结构体page_t（见&lt;code&gt;inc/pmm.h&lt;/code&gt;）：&lt;/p&gt;
&lt;p&gt;每一个页管理结构体存储了对应的一个或多个页的信息，包括：list（用于添加至空闲页表以标记每一个或一组空闲页），count（当前页引用计数），order（当前页管理结构体管理的页数为2的order次幂），flag（当前页状态）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; page_t* p_pages = (page_t*)(uint32_t)KERNEL_END + KERNEL_BASE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指向页管理结构体数组的指针p_pages（见&lt;code&gt;mm/pmm.c&lt;/code&gt;）:该页管理结构体数组中记录了NORMAL ZONE中所有页对应的页管理结构体。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; list_node free_list[MAX_ORDER + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;空闲页表free_list（见&lt;code&gt;mm/buddy.c&lt;/code&gt;）：空闲页表记录了每一个order的空闲页集合所对应的链表头，可根据表头查找出一组所需大小空闲页对应的list值并反向确定该组起始空闲页的位置。&lt;/p&gt;
&lt;h3 id=&#34;页管理算法&#34;&gt;页管理算法&lt;/h3&gt;
&lt;p&gt;选用了伙伴算法：
（updating&amp;hellip;）&lt;/p&gt;
- https://blanca.world/archives/%E5%8D%9A%E6%96%878-blanca-os%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>自制系统Blanca-OS记录（持续更新）</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E5%AE%A27-%E8%87%AA%E5%88%B6%E7%B3%BB%E7%BB%9Fblanca-os%E8%AE%B0%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</link>
        <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E5%AE%A27-%E8%87%AA%E5%88%B6%E7%B3%BB%E7%BB%9Fblanca-os%E8%AE%B0%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E5%AE%A27-%E8%87%AA%E5%88%B6%E7%B3%BB%E7%BB%9Fblanca-os%E8%AE%B0%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/ -&lt;h4 id=&#34;20200225&#34;&gt;2020.02.25&lt;/h4&gt;
&lt;p&gt;loader在加载内核文件到内存的时候出现莫名错误，表现为无法对某部分内存进行操作。起初排查认为是640KB以上至4GB的内存都无法写入，复查gdt表以及ds寄存器确认所选择的数据段覆盖了0-4GB范围，可读可写，经过十几小时的苦恼之后，终于尝试出1MB以上的内存可写入，而之前无法写入主要是因为我采用了640KB出头的内存区域及0xc0001500进行尝试,前者属于BIOS扩展区，无法写入，后者超出了我所设置的虚拟机的总内存32MB，属于不存在的区域，其实至今出现的很多莫名错误本质上都是小问题，但总会因为自己的粗心失误造成大量的时间损失。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200301&#34;&gt;2020.03.01&lt;/h4&gt;
&lt;p&gt;昨天把后面经常要用到的string库基本完成了，个别函数仍在选择更优的算法实现（原谅我的强迫症），今天正在看内核调试相关的资料，这几天准备完成printk函数及打印内核调用栈的debug函数。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200303&#34;&gt;2020.03.03&lt;/h4&gt;
&lt;p&gt;为了后续更方便的构造内核并写入虚拟机，选择使用makefile，研究了一晚上makefile的语法，写得我头大，不过初步有了头绪，刚刚在床上躺了一小时之后决定爬起来继续研究makefile，现在已经过零点了，确切的说现在已经是3月4号了（哭）。计组原理实验课后面还要造cpu，看来这学期是要忙死了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200304&#34;&gt;2020.03.04&lt;/h4&gt;
&lt;p&gt;凌晨在&lt;a href=&#34;https://github.com/Geno1024&#34;&gt;@geno&lt;/a&gt;与&lt;a href=&#34;https://github.com/AmazingRise&#34;&gt;@rise&lt;/a&gt;二位大佬的指点下，弄明白了makefile中折腾了我一晚上的问题，白天起床后边上网课边把项目的makefile基本写好了（我居然还是和老师互动最积极的学生。。你永远不知道上网课的学术在干什么.jpg），后续随着项目的进展还会继续调整makefile，短期之内是不用再为这玩意伤神了，继续投入精力去完成printk函数。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200305&#34;&gt;2020.03.05&lt;/h4&gt;
&lt;p&gt;添加了printk函数的vga支持（扩展内联汇编实属可怕，幸好目前用这玩意写的代码没几行），简易版的printk函数基本完成，后续可能根据需求进一步添加功能支持，但今天还没来得及对printk函数进行完备的测试，明天会测试一下修修bug，周末尽可能地搞定debug函数，下周估计就要开始给内核添加中断功能了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200306&#34;&gt;2020.03.06&lt;/h4&gt;
&lt;p&gt;今天测试了之后发现，写代码的过程中粗心写的bug还是很多的，除了printk相关的函数之外，makefile以及之前以为完全搞定的loader中也出现了点小bug，历时4个多小时，终于彻底搞定了printk函数的功能，一级残废内核Blanca-OS终于会开口说话了（笑），明天可能下乡一趟，回来之后再开始写debug函数，继续加油！btw,光靠bochs调试汇编代码还是太麻烦了，这两天捣鼓看看能不能把bochs和gdb连接到一起，直接在内核中用gdb调试c代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200311&#34;&gt;2020.03.11&lt;/h4&gt;
&lt;p&gt;debug这块思路基本理顺了，大体上各块功能差不多搞定了，最后的整合到打印调用栈这块还在思考，暂时决定等到写内存管理的时候一起完成，现在先跳过去把中断这块研究明白。这学期上网课真的好烦啊，各种群，各种平台，没完没了的作业。。。以及无力吐槽的辣鸡培养方案，这大学教育就很离谱。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200319&#34;&gt;2020.03.19&lt;/h4&gt;
&lt;p&gt;开学之后各种各样的事情多得离谱，写OS的时间都被挤得不剩啥了（说着突然想起来毛概作业要ddl了。。佛），不过好歹这几天把中断这块全理清了，预计本周末能把中断功能全部实现，下周向内存管理进军，冲鸭！&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200322&#34;&gt;2020.03.22&lt;/h4&gt;
&lt;p&gt;昨天搞定了中断功能，今天添加了计时器，并在中断的基础上测试了一下计时器，完全OK，今晚写一下assert和panic函数，明天应该就能正式开始内存管理器这块了，emmmm，debug还晾在那。。。带着一起搞搞看吧，搞不定就先继续晾着（实惨）。内存管理这块，因为之前做csapp的malloc lab有一点经验了，应该能很快搞定吧，争取在三月结束前搞定！&lt;/p&gt;
&lt;p&gt;睡觉前再次更新一下，assert和panic函数都添加好了。以及之前debug相关功能有些bug（主要指那个链接脚本），暂时把debug相关的代码注释了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200326&#34;&gt;2020.03.26&lt;/h4&gt;
&lt;p&gt;这两天一直在研究内存管理方面的算法，最后决定参考linux使用buddy算法加slab算法，目前刚写了个物理内存初始化的功能，昨天研究别人写的内核源码时被volatile和原子操作绕了进去（其实这两者没有关系），研究了一晚上，终于搞清楚来龙去脉了，后面可能写个博客记录一下。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200328&#34;&gt;2020.03.28&lt;/h4&gt;
&lt;p&gt;最近上课都在研究内核，课程落下不少，感觉这学期期末绩点，危！这两天结合了hurlex的源码以及linux2.6.11的源码（linux2.6.11的源码也太复杂了叭！一行行扒函数功能理依赖关系给我整哭辽也不过借鉴了个皮毛）整了下物理页结构体数组的初始化功能。附上目前的内存分布图（纯手打的图，丑哭了，以后可能补上真图）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

——————————————
|            |
|ZONE_HIGHMEM|
|            |
——————————————  &amp;lt;--3GB+896MB
|	     |
|内核可用物理页|
|            |
——————————————  &amp;lt;--pmm_addr_start
|            |
|  物理页数组  |
|            |
—————————————  &amp;lt;--p_pages
|	     |
|  内核镜像   |
|            |
——————————————  &amp;lt;--3GB+1MB
|            |
——————————————  &amp;lt;--3GB
|            |
|   用户空间  | 
|            |
——————————————

&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;20200402&#34;&gt;2020.04.02&lt;/h4&gt;
&lt;p&gt;基本搞定了物理内存管理的部分，阅读hurlex前辈的源码时发现了free函数中似乎有bug（还是很怀疑自我的，毕竟hurlex前辈的源码中写了测试功能，应该不会出这种问题的啊。。），纠结了一晚上，自己又写了将近一百行测试代码模拟了一下那段free函数的内存切割释放过程，最终基本肯定自己的想法是对的，fork，commit，push，pull request，一顿操作猛如虎，一看战力只有5,233,在线卑微，不过认真读读别人源码还是很爽的。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200420&#34;&gt;2020.04.20&lt;/h4&gt;
&lt;p&gt;有两周没更新记录了，主要是对内核空间和用户空间内存管理的分割有些许纠结，暂时是先抛开了用户空间的考量，后期再进行完善吧。这两天主要是在研究线程与进程的实现，目前有两种方案，一种是像早期linux一样，没有线程的概念，一切都归为任务，另一种是实现线程机制，然后基于此实现进程（任务）机制，还不确定选用哪种，参考了四份OS的源码，感觉虽然是两种方案，但大家总体的设计思路还是比较相近的。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200426&#34;&gt;2020.04.26&lt;/h4&gt;
&lt;p&gt;线程机制的总体设计基本厘情了（花的时间略长，最近事太多了，五一假期结束还有期中考试，太难顶了），明天差不多能把基本结构方面的代码搞定，还有调度要等到进程实现之后才写。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20200505&#34;&gt;2020.05.05&lt;/h4&gt;
&lt;p&gt;线程以及锁这块搞定了，准备实现完键盘驱动就去搞进程那块，最近和朋友以及学长交流得知这个OS可以作为毕业设计，所以开始在博客里同步更新各个模块的设计与实现方法，准备到大四的时候可以直接整合成一篇毕业论文，以后主要的记录都是更详细的分模块的博文，大概这篇零散记录的博文不会频繁更新了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;20210121&#34;&gt;2021.01.21&lt;/h4&gt;
&lt;p&gt;去年下半年父亲查出肝癌晚期，然后过世，给我带来了沉重打击，消沉了几个月，很多原定计划都被耽搁了，现在是时候继续开始前进了，预计３月开学前把这个OS基本完工，下学期该找实习了，加油！&lt;/p&gt;- https://blanca.world/archives/%E5%8D%9A%E5%AE%A27-%E8%87%AA%E5%88%B6%E7%B3%BB%E7%BB%9Fblanca-os%E8%AE%B0%E5%BD%95%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>2019年终总结</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E5%AE%A26-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E5%AE%A26-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E5%AE%A26-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ -&lt;p&gt;已经步入2020年的第十天了，才想起来写一篇2019年的总结（其实是看到某非著名网友🍞说：“大佬都是不写年终总结的。”看看自己这么菜，还是写点总结反省反省比较好。）&lt;/p&gt;
&lt;p&gt;前几天看到轮子哥发了一篇文章：&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;你只是在去死&#34;&gt;&lt;em&gt;你只是在去死&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;大家都要高考，高考是最重要的。那你是不是就把所有的时间都投入高考其他的全部都不做了呢？对大部分人来说就是这样的。古典音乐不需要被高考，所以就不做。甚至连与大学密切相关的专业调研都不做，所有的时间都花在高考上。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你终于考上大学了，因为你只高考，别人也只高考，大家都在内卷，你并没有任何优势。你发现之前高中学的东西除了数学英语以外基本就可以扔掉了。为什么呢？因为大学不考语文呀。就算有些人要学物理，基本上也是重新学的，高中物理除了几个哲学思想以外也没有用了。你要的是毕业，所以你只做跟毕业考研拿奖有关的事情。甚至专业的内容都不好好学，想着反正我也不一定干这一行对吧，学的好也没奖学金，考研也不考。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;填志愿的时候压根不知道这些专业都是什么东西，大学快读完了你甚至不知道该如何在考研和找工作里面选择，甚至找工作也不知道找什么，最后都只退化为一个指标：考分数高的，找给钱多的。万一找不到怎么办？你也不知道。想想你是不是这样。如果不是，恭喜你（逃&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;后来你真的毕业了，还找到了个不错的工作，你就只赚钱买房了。买完房结婚，结婚完生小孩，你只赚钱和带小孩。小孩读书了，你就只赚钱和供小孩读书。小孩如果成绩不好，你就只赚钱、供小孩读书和生气。小孩成绩好，你就只赚钱、供小孩读书和不生气。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;小孩毕业了，只把自己的钱给小孩买房，可能你都给不起了因为你房贷也就刚还完，只会听到小孩说什么本事都没有干嘛把我生下来。小孩结婚生孩子了，你也退休了，你只带孙子。现在医疗发达了，你苟到了孙子终于也大学毕业的时候，你也可以去死了，因为除了去死也没有什么用了，所以你只去死。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;于是你在病床上回顾你这一生。你做过什么事情吗？没有。你活过吗？也没有。你只是在繁殖而已，毕竟这就是大自然进化出来的作为生物的目的。钱也都在房子里没有为自己花过，等于没赚过钱。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感触其实挺深，2019年这一整年我都在思考自己到底想做什么，哪些事于我是有意义的，怎样才能活得快乐些。&lt;/p&gt;
&lt;p&gt;上半年学了点函数式编程和零散的算法，其实也没干成啥事。暑假开始刷CSAPP，结果刷了没几天，扁桃体化脓，痛不欲生了好多天，大半个暑假就浑浑噩噩地过去了，其间女朋友也在爆肝国赛，经常性地莫名其妙和我吵起来，着实让我伤神。9月开学后，继续开始啃CSAPP，确实受益匪浅，顺带看了一下x86汇编并入了c++的坑（吐槽一下，c++的确很复杂），&lt;del&gt;变成了GDB调试小能手&lt;/del&gt;，这段时间，因为沉迷计算机以及因为和女朋友的多次矛盾开始下意识地躲着她，最终导致了被分手（我活该，我有罪，但我真的希望两个人之间多点信任和理解，少一点埋怨，很多时候我真的不明白“为什么这种事也值得吵起来啊？）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xclwt-blog-image.oss-cn-hangzhou.aliyuncs.com/20-01-11/gOBbn.jpg&#34; alt=&#34; &#34;&gt;&lt;/p&gt;
&lt;p&gt;就这样，没有了儿女情长的拖累，重新变成单身狗的我&lt;del&gt;难过&lt;/del&gt;快乐地开启了操作系统的学习，入了自制kernel的坑（&lt;a href=&#34;https://github.com/xclwt/Blanca-OS&#34;&gt;Blanca-OS&lt;/a&gt;）磨来磨去磨了个BootLoader出来，要考试了，只能先放下我的操作系统。&lt;/p&gt;
&lt;p&gt;2019年，我变得越来越不关心绩点和奖学金什么的了（笑），为这种东西争来争去实在是浪费时间，学校安排的课程也不想学，大多数时间都泡在图书馆写自己的代码，大概不少人会觉得我这样是在做傻事，嗯，我挺想多做点这样傻事的，我只是不想就这么去死罢了。&lt;/p&gt;
&lt;p&gt;2019年，我的github contribution只有零星的几个绿点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xclwt-blog-image.oss-cn-hangzhou.aliyuncs.com/20-01-11/blog7.png&#34; alt=&#34; &#34;&gt;&lt;/p&gt;
&lt;p&gt;希望2020年，我的github contribution能变成青青草原，自制kernel大概会是我学习生涯中的一个转折点，我希望自己能把这件傻事做好。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;- https://blanca.world/archives/%E5%8D%9A%E5%AE%A26-2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/ - 咸鱼白</description>
        </item>
    
    
    
        <item>
        <title>如何拆除CMU-15213的bomb lab？（2）</title>
        <link>https://blanca.world/archives/%E5%8D%9A%E6%96%875-%E5%A6%82%E4%BD%95%E6%8B%86%E9%99%A4cmu-15213%E7%9A%84bomb-lab2/</link>
        <pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate>
        
        <guid>https://blanca.world/archives/%E5%8D%9A%E6%96%875-%E5%A6%82%E4%BD%95%E6%8B%86%E9%99%A4cmu-15213%E7%9A%84bomb-lab2/</guid>
        <description>咸鱼白的窝 https://blanca.world/archives/%E5%8D%9A%E6%96%875-%E5%A6%82%E4%BD%95%E6%8B%86%E9%99%A4cmu-15213%E7%9A%84bomb-lab2/ -&lt;h3 id=&#34;phase-3&#34;&gt;phase 3：&lt;/h3&gt;
&lt;p&gt;执行以下操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0x400e72&lt;/span&gt;		&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;在&lt;/span&gt;phase_3函数调用处设置断点
......
&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;（输入任意字符串）&lt;/span&gt;
stepi 				&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;单步执行，进入&lt;/span&gt;phase_3函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进入phase_3函数后，我们可以看到程序在栈上分配了24字节空间，我们把现在的栈顶称为s1：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f43&lt;/span&gt; &amp;lt;phase_3&amp;gt;      sub    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x18&lt;/span&gt;,%rsp
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f47&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;&amp;gt;    lea    &lt;span style=&#34;color:#b452cd&#34;&gt;0xc&lt;/span&gt;(%rsp),%rcx        &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; %rcx值设为s1+&lt;span style=&#34;color:#b452cd&#34;&gt;12&lt;/span&gt; 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f4c&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;9&lt;/span&gt;&amp;gt;    lea    &lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;(%rsp),%rdx		&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; %rdx值设为s1+&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来又出现了包含即时数的操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f51&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;14&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x4025cf&lt;/span&gt;,%esi
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f56&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;19&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x0&lt;/span&gt;,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f5b&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;24&lt;/span&gt;&amp;gt;   callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x400bf0&lt;/span&gt; &amp;lt;__isoc99_sscanf&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;@&lt;/span&gt;plt&amp;gt;
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f60&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;29&lt;/span&gt;&amp;gt;   cmp    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x1&lt;/span&gt;,%eax                           
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f63&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;32&lt;/span&gt;&amp;gt;   jg     &lt;span style=&#34;color:#b452cd&#34;&gt;0x400f6a&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;39&lt;/span&gt;&amp;gt;                   
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f65&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;34&lt;/span&gt;&amp;gt;   callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们来看看这个地址里有什么，输入：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;x/s &lt;span style=&#34;color:#b452cd&#34;&gt;0x4025cf&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到返回值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x4025cf&lt;/span&gt;:       &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;并且又调用了sscanf操作，并且返回值小于等于1会触发炸弹，所以此处应该是从我们输入的字符串中读入了2个整数。&lt;/p&gt;
&lt;p&gt;重新进入phase3（此次的密钥输入两个任意整数），继续往下读：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f6a&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;39&lt;/span&gt;&amp;gt;   cmpl   &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x7&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;(%rsp)
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f6f&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;44&lt;/span&gt;&amp;gt;   ja     &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fad&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;106&lt;/span&gt;&amp;gt; 
......
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fad&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;106&lt;/span&gt;&amp;gt;  callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此处出现了s1+8存储的值与7的比较，执行以下操作查看s1+8存储的值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;x/x &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;rsp+&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们会发现该值正是我们输入的第一个整数,若这个数大于7,则会跳转到explode_bomb函数的调用，注意此处的跳转使用的是ja命令，说明上一步执行了对无符号整数的比较，故我们输入的第一个整数范围应当是0-7。&lt;/p&gt;
&lt;p&gt;再向下看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f71&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;46&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;(%rsp),%eax                         
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f75&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;50&lt;/span&gt;&amp;gt;   jmpq   *&lt;span style=&#34;color:#b452cd&#34;&gt;0x402470&lt;/span&gt;(,%rax,&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;)                     
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f7c&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;57&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0xcf&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f81&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;62&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f83&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;64&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x2c3&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f88&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;69&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f8a&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;71&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x100&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f8f&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;76&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f91&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;78&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x185&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f96&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;83&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f98&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;85&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0xce&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f9d&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;90&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400f9f&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;92&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x2aa&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fa4&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;97&lt;/span&gt;&amp;gt;   jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fa6&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;99&lt;/span&gt;&amp;gt;   mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x147&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fab&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;104&lt;/span&gt;&amp;gt;  jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fad&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;106&lt;/span&gt;&amp;gt;  callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fb2&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;111&lt;/span&gt;&amp;gt;  mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x0&lt;/span&gt;,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fb7&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;116&lt;/span&gt;&amp;gt;  jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fb9&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;118&lt;/span&gt;&amp;gt;  mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x137&lt;/span&gt;,%eax                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;  cmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0xc&lt;/span&gt;(%rsp),%eax                         
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fc2&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;127&lt;/span&gt;&amp;gt;  je     &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fc9&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;134&lt;/span&gt;&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fc4&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;129&lt;/span&gt;&amp;gt;  callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt;                 
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fc9&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;134&lt;/span&gt;&amp;gt;  add    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x18&lt;/span&gt;,%rsp                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fcd&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;138&lt;/span&gt;&amp;gt;  retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们输入的第一个整数被移入%rax寄存器，并且在下一步操作中直接跳转到了（0x402470+%rax×8）地址中存储的位置，因为我们输入的整数范围0-7,而十六进制整型数据占用4个字节，则%rax×8跨越15个内存地址，所以尝试执行以下指令查看从0x402470往后16个内存地址的内容（每个内存地址4字节）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;x/&lt;span style=&#34;color:#b452cd&#34;&gt;16&lt;/span&gt;xw &lt;span style=&#34;color:#b452cd&#34;&gt;0x402470&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x402470&lt;/span&gt;:       &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f7c&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400fb9&lt;/span&gt;      
&lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;
&lt;span style=&#34;color:#b452cd&#34;&gt;0x402480&lt;/span&gt;:       &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f83&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f8a&lt;/span&gt;      
&lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;
&lt;span style=&#34;color:#b452cd&#34;&gt;0x402490&lt;/span&gt;:       &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f91&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f98&lt;/span&gt;      
&lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;
&lt;span style=&#34;color:#b452cd&#34;&gt;0x4024a0&lt;/span&gt;:       &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400f9f&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;      &lt;span style=&#34;color:#b452cd&#34;&gt;0x00400fa6&lt;/span&gt;      
&lt;span style=&#34;color:#b452cd&#34;&gt;0x00000000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中有8个非0的十六进制数，我们仔细比对可以发现正可以与后面尚未执行的指令中的8个的地址相对应。这8个指令，每个都是执行将一个十六进制整型数传入寄存器%eax的指令，紧接其后都是跳转向了这条指令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fbe&lt;/span&gt; &amp;lt;phase_3+&lt;span style=&#34;color:#b452cd&#34;&gt;123&lt;/span&gt;&amp;gt;  cmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0xc&lt;/span&gt;(%rsp),%eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将s1+12处的数（就是我们输入的第二个整数）与寄存器%eax中的数比较，若相同便不回触发炸弹。&lt;/p&gt;
&lt;p&gt;至此，我们可以理清楚了：当输入的第一个整数为0-7时，分别有一个对应的第二个整数可以通过关卡3.&lt;/p&gt;
&lt;p&gt;仔细对比指令中的组合，我们最终得到了以下8组整数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 207
1 311
2 707
3 256
4 389
5 206
6 682
7 327
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至此，phase 3通过。&lt;/p&gt;
&lt;h3 id=&#34;phase-4&#34;&gt;phase 4：&lt;/h3&gt;
&lt;p&gt;执行以下操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;break&lt;/span&gt; * &lt;span style=&#34;color:#b452cd&#34;&gt;0x400e8e&lt;/span&gt;		&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;在&lt;/span&gt;phase_4函数调用处设置断点
......
&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;（输入任意字符串）&lt;/span&gt;
stepi					&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#单步执行进入&lt;/span&gt;phase_2函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一如既往的，我们见到了含有立即数的指令并且很容易得出了对我们输入字符串的要求是两个整数。往下看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x40102e&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;34&lt;/span&gt;&amp;gt;   cmpl   &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0xe&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;(%rsp)           
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401033&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;39&lt;/span&gt;&amp;gt;   jbe    &lt;span style=&#34;color:#b452cd&#34;&gt;0x40103a&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;46&lt;/span&gt;&amp;gt;  
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401035&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;41&lt;/span&gt;&amp;gt;   callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;程序将我们输入的第一个整数与14比较，如果大于14就会触发炸弹，并且由jbe指令我们可以得出输入的第一个整数应该是0-14中的任一无符号整数。&lt;/p&gt;
&lt;p&gt;再往后看，调用了函数func4,且返回值不为0会触发炸弹，进入函数func4看看：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fce&lt;/span&gt; &amp;lt;func4&amp;gt;        sub    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;,%rsp                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fd2&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;4&lt;/span&gt;&amp;gt;      mov    %edx,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fd4&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt;&amp;gt;      sub    %esi,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fd6&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt;&amp;gt;      mov    %eax,%ecx                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fd8&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;&amp;gt;     shr    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x1f&lt;/span&gt;,%ecx                             
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fdb&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;13&lt;/span&gt;&amp;gt;     add    %ecx,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fdd&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;15&lt;/span&gt;&amp;gt;     sar    %eax                                   
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fdf&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;17&lt;/span&gt;&amp;gt;     lea    (%rax,%rsi,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;),%ecx                     
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fe2&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;20&lt;/span&gt;&amp;gt;     cmp    %edi,%ecx                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fe4&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;22&lt;/span&gt;&amp;gt;     jle    &lt;span style=&#34;color:#b452cd&#34;&gt;0x400ff2&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;36&lt;/span&gt;&amp;gt;                     
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fe6&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;24&lt;/span&gt;&amp;gt;     lea    -&lt;span style=&#34;color:#b452cd&#34;&gt;0x1&lt;/span&gt;(%rcx),%edx                         
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fe9&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;27&lt;/span&gt;&amp;gt;     callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fce&lt;/span&gt; &amp;lt;func4&amp;gt;                       
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400fee&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;32&lt;/span&gt;&amp;gt;     add    %eax,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ff0&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;34&lt;/span&gt;&amp;gt;     jmp    &lt;span style=&#34;color:#b452cd&#34;&gt;0x401007&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;57&lt;/span&gt;&amp;gt;                     
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ff2&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;36&lt;/span&gt;&amp;gt;     mov    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x0&lt;/span&gt;,%eax                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ff7&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;41&lt;/span&gt;&amp;gt;     cmp    %edi,%ecx                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ff9&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;43&lt;/span&gt;&amp;gt;     jge    &lt;span style=&#34;color:#b452cd&#34;&gt;0x401007&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;57&lt;/span&gt;&amp;gt;                     
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ffb&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;45&lt;/span&gt;&amp;gt;     lea    &lt;span style=&#34;color:#b452cd&#34;&gt;0x1&lt;/span&gt;(%rcx),%esi                         
&lt;span style=&#34;color:#b452cd&#34;&gt;0x400ffe&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;48&lt;/span&gt;&amp;gt;     callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x400fce&lt;/span&gt; &amp;lt;func4&amp;gt;                       
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401003&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;53&lt;/span&gt;&amp;gt;     lea    &lt;span style=&#34;color:#b452cd&#34;&gt;0x1&lt;/span&gt;(%rax,%rax,&lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;),%eax                   
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401007&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;57&lt;/span&gt;&amp;gt;     add    &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x8&lt;/span&gt;,%rsp                               
&lt;span style=&#34;color:#b452cd&#34;&gt;0x40100b&lt;/span&gt; &amp;lt;func4+&lt;span style=&#34;color:#b452cd&#34;&gt;61&lt;/span&gt;&amp;gt;     retq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在func4中，我们可以看到存在调用自身的操作，这应该是个递归函数，逻辑不是很清楚，尝试用逆向工程的方法将其还原为如下c程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;func4&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; y){				&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;#&lt;/span&gt; num为我们输入的第一个整数
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; result = x - y;
    result /= &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; temp = result + y;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (temp &amp;lt; num){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; * func(num, x, temp + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;) + &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (temp &amp;gt; num){
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; * func4(num, temp - &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;, y);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;根据这段c程序很容易推演出当我们输入的第一个整数为0,1,3,7时，func4返回值为0。&lt;/p&gt;
&lt;p&gt;回到phase_4继续看&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x401051&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;69&lt;/span&gt;&amp;gt;   cmpl   &lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;$&lt;/span&gt;&lt;span style=&#34;color:#b452cd&#34;&gt;0x0&lt;/span&gt;,&lt;span style=&#34;color:#b452cd&#34;&gt;0xc&lt;/span&gt;(%rsp)                         
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401056&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;74&lt;/span&gt;&amp;gt;   je     &lt;span style=&#34;color:#b452cd&#34;&gt;0x40105d&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;81&lt;/span&gt;&amp;gt;                   
&lt;span style=&#34;color:#b452cd&#34;&gt;0x401058&lt;/span&gt; &amp;lt;phase_4+&lt;span style=&#34;color:#b452cd&#34;&gt;76&lt;/span&gt;&amp;gt;   callq  &lt;span style=&#34;color:#b452cd&#34;&gt;0x40143a&lt;/span&gt; &amp;lt;explode_bomb&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段程序将第二个整数与0比较，若不想等就会触发炸弹，所以，第二个整数应该为0。&lt;/p&gt;
&lt;p&gt;至此，phase 4通过。&lt;/p&gt;
&lt;p&gt;(在写5，6关的解法时和人怼了起来导致最后半途而废，抱歉)&lt;/p&gt;- https://blanca.world/archives/%E5%8D%9A%E6%96%875-%E5%A6%82%E4%BD%95%E6%8B%86%E9%99%A4cmu-15213%E7%9A%84bomb-lab2/ - 咸鱼白</description>
        </item>
    
    
  </channel>
</rss> 